<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ogr.services.github.project API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ogr.services.github.project</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright Contributors to the Packit project.
# SPDX-License-Identifier: MIT

import datetime
import logging
from ogr.services.github.check_run import (
    GithubCheckRun,
    GithubCheckRunOutput,
    GithubCheckRunResult,
    GithubCheckRunStatus,
)
from typing import Optional, Dict, List, Set, Union

import github
from github import UnknownObjectException
from github.GithubException import GithubException
from github.Repository import Repository
from github.Commit import Commit
from github.CommitComment import CommitComment as GithubCommitComment

from ogr.abstract import (
    Issue,
    IssueStatus,
    PullRequest,
    PRStatus,
    Release,
    CommitComment,
    GitTag,
    CommitFlag,
    CommitStatus,
    AccessLevel,
)
from ogr.exceptions import GithubAPIException, OperationNotSupported
from ogr.read_only import if_readonly, GitProjectReadOnly
from ogr.services import github as ogr_github
from ogr.services.base import BaseGitProject
from ogr.services.github.flag import GithubCommitFlag
from ogr.services.github.issue import GithubIssue
from ogr.services.github.pull_request import GithubPullRequest
from ogr.services.github.release import GithubRelease
from ogr.utils import filter_paths, indirect

logger = logging.getLogger(__name__)


class GithubProject(BaseGitProject):
    service: &#34;ogr_github.GithubService&#34;
    # Permission levels that can merge PRs
    CAN_MERGE_PERMS = [&#34;admin&#34;, &#34;write&#34;]

    def __init__(
        self,
        repo: str,
        service: &#34;ogr_github.GithubService&#34;,
        namespace: str,
        github_repo: Repository = None,
        read_only: bool = False,
        **unprocess_kwargs,
    ) -&gt; None:
        if unprocess_kwargs:
            logger.warning(
                f&#34;GithubProject will not process these kwargs: {unprocess_kwargs}&#34;
            )
        super().__init__(repo, service, namespace)
        self._github_repo = github_repo
        self.read_only = read_only

        self._github_instance = None

    @property
    def github_instance(self):
        if not self._github_instance:
            self._github_instance = self.service.get_pygithub_instance(
                self.namespace, self.repo
            )

        return self._github_instance

    @property
    def github_repo(self):
        if not self._github_repo:
            self._github_repo = self.github_instance.get_repo(
                full_name_or_id=f&#34;{self.namespace}/{self.repo}&#34;
            )
        return self._github_repo

    def __str__(self) -&gt; str:
        return f&#39;GithubProject(namespace=&#34;{self.namespace}&#34;, repo=&#34;{self.repo}&#34;)&#39;

    def __eq__(self, o: object) -&gt; bool:
        if not isinstance(o, GithubProject):
            return False

        return (
            self.repo == o.repo
            and self.namespace == o.namespace
            and self.service == o.service
            and self.read_only == o.read_only
        )

    @property
    def description(self) -&gt; str:
        return self.github_repo.description

    @description.setter
    def description(self, new_description: str) -&gt; None:
        self.github_repo.edit(description=new_description)

    @property
    def has_issues(self) -&gt; bool:
        return self.github_repo.has_issues

    def _construct_fork_project(self) -&gt; Optional[&#34;GithubProject&#34;]:
        gh_user = self.github_instance.get_user()
        user_login = gh_user.login
        try:
            project = GithubProject(
                self.repo, self.service, namespace=user_login, read_only=self.read_only
            )
            if not project.github_repo:
                # The github_repo attribute is lazy.
                return None
            return project
        except github.GithubException as ex:
            logger.debug(f&#34;Project {user_login}/{self.repo} does not exist: {ex}&#34;)
            return None

    def exists(self) -&gt; bool:
        try:
            _ = self.github_repo
            return True
        except UnknownObjectException as ex:
            if &#34;Not Found&#34; in str(ex):
                return False
            raise GithubAPIException from ex

    def is_private(self) -&gt; bool:
        return self.github_repo.private

    def is_forked(self) -&gt; bool:
        return bool(self._construct_fork_project())

    @property
    def is_fork(self) -&gt; bool:
        return self.github_repo.fork

    @property
    def parent(self) -&gt; Optional[&#34;GithubProject&#34;]:
        return (
            self.service.get_project_from_github_repository(self.github_repo.parent)
            if self.is_fork
            else None
        )

    @property
    def default_branch(self):
        return self.github_repo.default_branch

    def get_branches(self) -&gt; List[str]:
        return [branch.name for branch in self.github_repo.get_branches()]

    def get_description(self) -&gt; str:
        return self.github_repo.description

    def add_user(self, user: str, access_level: AccessLevel) -&gt; None:
        access_dict = {
            AccessLevel.pull: &#34;Pull&#34;,
            AccessLevel.triage: &#34;Triage&#34;,
            AccessLevel.push: &#34;Push&#34;,
            AccessLevel.admin: &#34;Admin&#34;,
            AccessLevel.maintain: &#34;Maintain&#34;,
        }
        try:
            invitation = self.github_repo.add_to_collaborators(
                user, permission=access_dict[access_level]
            )
        except Exception as ex:
            raise GithubAPIException(f&#34;User {user} not found&#34;) from ex

        if invitation is None:
            raise GithubAPIException(&#34;User already added&#34;)

    def request_access(self):
        raise OperationNotSupported(&#34;Not possible on GitHub&#34;)

    def get_fork(self, create: bool = True) -&gt; Optional[&#34;GithubProject&#34;]:
        username = self.service.user.get_username()
        for fork in self.get_forks():
            if fork.github_repo.owner.login == username:
                return fork

        if not self.is_forked():
            if create:
                return self.fork_create()
            else:
                logger.info(
                    f&#34;Fork of {self.github_repo.full_name}&#34;
                    &#34; does not exist and we were asked not to create it.&#34;
                )
                return None
        return self._construct_fork_project()

    def get_owners(self) -&gt; List[str]:
        # in case of github, repository has only one owner
        return [self.github_repo.owner.login]

    def __get_collaborators(self) -&gt; Set[str]:
        try:
            collaborators = self._get_collaborators_with_permission()
        except github.GithubException:
            logger.debug(
                &#34;Current Github token must have push access to view repository permissions.&#34;
            )
            return set()

        usernames = []
        for login, permission in collaborators.items():
            if permission in self.CAN_MERGE_PERMS:
                usernames.append(login)

        return set(usernames)

    def who_can_close_issue(self) -&gt; Set[str]:
        return self.__get_collaborators()

    def who_can_merge_pr(self) -&gt; Set[str]:
        return self.__get_collaborators()

    def can_merge_pr(self, username) -&gt; bool:
        return (
            self.github_repo.get_collaborator_permission(username)
            in self.CAN_MERGE_PERMS
        )

    def _get_collaborators_with_permission(self) -&gt; dict:
        &#34;&#34;&#34;
        Get all project collaborators in dictionary with permission association.

        Returns:
            Dictionary with logins of collaborators and their permission level.
        &#34;&#34;&#34;
        collaborators = {}
        users = self.github_repo.get_collaborators()
        for user in users:
            permission = self.github_repo.get_collaborator_permission(user)
            collaborators[user.login] = permission
        return collaborators

    @indirect(GithubIssue.get_list)
    def get_issue_list(
        self,
        status: IssueStatus = IssueStatus.open,
        author: Optional[str] = None,
        assignee: Optional[str] = None,
        labels: Optional[List[str]] = None,
    ) -&gt; List[Issue]:
        pass

    @indirect(GithubIssue.get)
    def get_issue(self, issue_id: int) -&gt; Issue:
        pass

    @indirect(GithubIssue.create)
    def create_issue(
        self,
        title: str,
        body: str,
        private: Optional[bool] = None,
        labels: Optional[List[str]] = None,
        assignees: Optional[List[str]] = None,
    ) -&gt; Issue:
        pass

    def delete(self) -&gt; None:
        self.github_repo.delete()

    @indirect(GithubPullRequest.get_list)
    def get_pr_list(self, status: PRStatus = PRStatus.open) -&gt; List[PullRequest]:
        pass

    @indirect(GithubPullRequest.get)
    def get_pr(self, pr_id: int) -&gt; PullRequest:
        pass

    def get_sha_from_tag(self, tag_name: str) -&gt; str:
        # TODO: This is ugly. Can we do it better?
        all_tags = self.github_repo.get_tags()
        for tag in all_tags:
            if tag.name == tag_name:
                return tag.commit.sha
        raise GithubAPIException(f&#34;Tag {tag_name} was not found.&#34;)

    def get_tag_from_tag_name(self, tag_name: str) -&gt; Optional[GitTag]:
        &#34;&#34;&#34;
        Get a tag based on a tag name.

        Args:
            tag_name: Name of the tag.

        Returns:
            GitTag associated with the given tag name or `None`.
        &#34;&#34;&#34;
        all_tags = self.github_repo.get_tags()
        for tag in all_tags:
            if tag.name == tag_name:
                return GitTag(name=tag.name, commit_sha=tag.commit.sha)
        return None

    @if_readonly(return_function=GitProjectReadOnly.create_pr)
    @indirect(GithubPullRequest.create)
    def create_pr(
        self,
        title: str,
        body: str,
        target_branch: str,
        source_branch: str,
        fork_username: str = None,
    ) -&gt; PullRequest:
        pass

    @if_readonly(
        return_function=GitProjectReadOnly.commit_comment,
        log_message=&#34;Create Comment to commit&#34;,
    )
    def commit_comment(
        self, commit: str, body: str, filename: str = None, row: int = None
    ) -&gt; CommitComment:
        github_commit: Commit = self.github_repo.get_commit(commit)
        if filename and row:
            comment = github_commit.create_comment(
                body=body, position=row, path=filename
            )
        else:
            comment = github_commit.create_comment(body=body)
        return self._commit_comment_from_github_object(comment)

    @staticmethod
    def _commit_comment_from_github_object(
        raw_commit_coment: GithubCommitComment,
    ) -&gt; CommitComment:
        return CommitComment(
            body=raw_commit_coment.body,
            author=raw_commit_coment.user.login,
            sha=raw_commit_coment.commit_id,
        )

    def get_commit_comments(self, commit: str) -&gt; List[CommitComment]:
        github_commit: Commit = self.github_repo.get_commit(commit)
        return [
            self._commit_comment_from_github_object(comment)
            for comment in github_commit.get_comments()
        ]

    @if_readonly(
        return_function=GitProjectReadOnly.set_commit_status,
        log_message=&#34;Create a status on a commit&#34;,
    )
    @indirect(GithubCommitFlag.set)
    def set_commit_status(
        self,
        commit: str,
        state: Union[CommitStatus, str],
        target_url: str,
        description: str,
        context: str,
        trim: bool = False,
    ):
        pass

    @indirect(GithubCommitFlag.get)
    def get_commit_statuses(self, commit: str) -&gt; List[CommitFlag]:
        pass

    @indirect(GithubCheckRun.get)
    def get_check_run(
        self,
        check_run_id: Optional[int] = None,
        commit_sha: Optional[str] = None,
    ) -&gt; Optional[&#34;GithubCheckRun&#34;]:
        pass

    @indirect(GithubCheckRun.create)
    def create_check_run(
        self,
        name: str,
        commit_sha: str,
        url: Optional[str] = None,
        external_id: Optional[str] = None,
        status: GithubCheckRunStatus = GithubCheckRunStatus.queued,
        started_at: Optional[datetime.datetime] = None,
        conclusion: Optional[GithubCheckRunResult] = None,
        completed_at: Optional[datetime.datetime] = None,
        output: Optional[GithubCheckRunOutput] = None,
        actions: Optional[List[Dict[str, str]]] = None,
    ) -&gt; &#34;GithubCheckRun&#34;:
        pass

    @indirect(GithubCheckRun.get_list)
    def get_check_runs(
        self,
        commit_sha: str,
        name: Optional[str] = None,
        status: Optional[GithubCheckRunStatus] = None,
    ) -&gt; List[&#34;GithubCheckRun&#34;]:
        pass

    def get_git_urls(self) -&gt; Dict[str, str]:
        return {&#34;git&#34;: self.github_repo.clone_url, &#34;ssh&#34;: self.github_repo.ssh_url}

    @if_readonly(return_function=GitProjectReadOnly.fork_create)
    def fork_create(self, namespace: Optional[str] = None) -&gt; &#34;GithubProject&#34;:
        fork_repo = (
            self.github_repo.create_fork(organization=namespace)
            if namespace
            else self.github_repo.create_fork()
        )

        fork = self.service.get_project_from_github_repository(fork_repo)
        logger.debug(f&#34;Forked to {fork.namespace}/{fork.repo}&#34;)
        return fork

    def change_token(self, new_token: str):
        raise OperationNotSupported

    def get_file_content(self, path: str, ref=None) -&gt; str:
        ref = ref or self.default_branch
        try:
            return self.github_repo.get_contents(
                path=path, ref=ref
            ).decoded_content.decode()
        except (UnknownObjectException, GithubException) as ex:
            if ex.status == 404:
                raise FileNotFoundError(f&#34;File &#39;{path}&#39; on {ref} not found&#34;) from ex
            raise GithubAPIException() from ex

    def get_files(
        self, ref: str = None, filter_regex: str = None, recursive: bool = False
    ) -&gt; List[str]:
        ref = ref or self.default_branch
        paths = []
        contents = self.github_repo.get_contents(path=&#34;&#34;, ref=ref)

        if recursive:
            while contents:
                file_content = contents.pop(0)
                if file_content.type == &#34;dir&#34;:
                    contents.extend(
                        self.github_repo.get_contents(path=file_content.path, ref=ref)
                    )
                else:
                    paths.append(file_content.path)

        else:
            paths = [
                file_content.path
                for file_content in contents
                if file_content.type != &#34;dir&#34;
            ]

        if filter_regex:
            paths = filter_paths(paths, filter_regex)

        return paths

    def get_labels(self):
        &#34;&#34;&#34;
        Get list of labels in the repository.

        Returns:
            List of labels in the repository.
        &#34;&#34;&#34;
        return list(self.github_repo.get_labels())

    def update_labels(self, labels):
        &#34;&#34;&#34;
        Update the labels of the repository. (No deletion, only add not existing ones.)

        Args:
            labels: List of labels to be added.

        Returns:
            Number of added labels.
        &#34;&#34;&#34;
        current_label_names = [la.name for la in list(self.github_repo.get_labels())]
        changes = 0
        for label in labels:
            if label.name not in current_label_names:
                color = self._normalize_label_color(color=label.color)
                self.github_repo.create_label(
                    name=label.name, color=color, description=label.description or &#34;&#34;
                )

                changes += 1
        return changes

    @staticmethod
    def _normalize_label_color(color):
        if color.startswith(&#34;#&#34;):
            return color[1:]
        return color

    @indirect(GithubRelease.get)
    def get_release(self, identifier=None, name=None, tag_name=None) -&gt; GithubRelease:
        pass

    @indirect(GithubRelease.get_latest)
    def get_latest_release(self) -&gt; Optional[GithubRelease]:
        pass

    @indirect(GithubRelease.get_list)
    def get_releases(self) -&gt; List[Release]:
        pass

    @indirect(GithubRelease.create)
    def create_release(self, tag: str, name: str, message: str) -&gt; GithubRelease:
        pass

    def get_forks(self) -&gt; List[&#34;GithubProject&#34;]:
        return [
            self.service.get_project_from_github_repository(fork)
            for fork in self.github_repo.get_forks()
            if fork.owner
        ]

    def get_web_url(self) -&gt; str:
        return self.github_repo.html_url

    def get_tags(self) -&gt; List[&#34;GitTag&#34;]:
        return [GitTag(tag.name, tag.commit.sha) for tag in self.github_repo.get_tags()]

    def get_sha_from_branch(self, branch: str) -&gt; Optional[str]:
        try:
            return self.github_repo.get_branch(branch).commit.sha
        except GithubException as ex:
            if ex.status == 404:
                return None
            raise GithubAPIException from ex

    def get_contributors(self) -&gt; Set[str]:
        &#34;&#34;&#34;
        Returns:
            Logins of contributors to the project.
        &#34;&#34;&#34;
        return set(map(lambda c: c.login, self.github_repo.get_contributors()))

    def users_with_write_access(self) -&gt; Set[str]:
        return self.__get_collaborators()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ogr.services.github.project.GithubProject"><code class="flex name class">
<span>class <span class="ident">GithubProject</span></span>
<span>(</span><span>repo: str, service: ogr_github.GithubService, namespace: str, github_repo: github.Repository.Repository = None, read_only: bool = False, **unprocess_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>repo</code></strong></dt>
<dd>Name of the project.</dd>
<dt><strong><code>service</code></strong></dt>
<dd>GitService instance.</dd>
<dt><strong><code>namespace</code></strong></dt>
<dd>
<p>Namespace of the project.</p>
<ul>
<li>GitHub: username or org name.</li>
<li>GitLab: username or org name.</li>
<li>Pagure: namespace (e.g. <code>"rpms"</code>).</li>
</ul>
<p>In case of forks: <code>"fork/{username}/{namespace}"</code>.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GithubProject(BaseGitProject):
    service: &#34;ogr_github.GithubService&#34;
    # Permission levels that can merge PRs
    CAN_MERGE_PERMS = [&#34;admin&#34;, &#34;write&#34;]

    def __init__(
        self,
        repo: str,
        service: &#34;ogr_github.GithubService&#34;,
        namespace: str,
        github_repo: Repository = None,
        read_only: bool = False,
        **unprocess_kwargs,
    ) -&gt; None:
        if unprocess_kwargs:
            logger.warning(
                f&#34;GithubProject will not process these kwargs: {unprocess_kwargs}&#34;
            )
        super().__init__(repo, service, namespace)
        self._github_repo = github_repo
        self.read_only = read_only

        self._github_instance = None

    @property
    def github_instance(self):
        if not self._github_instance:
            self._github_instance = self.service.get_pygithub_instance(
                self.namespace, self.repo
            )

        return self._github_instance

    @property
    def github_repo(self):
        if not self._github_repo:
            self._github_repo = self.github_instance.get_repo(
                full_name_or_id=f&#34;{self.namespace}/{self.repo}&#34;
            )
        return self._github_repo

    def __str__(self) -&gt; str:
        return f&#39;GithubProject(namespace=&#34;{self.namespace}&#34;, repo=&#34;{self.repo}&#34;)&#39;

    def __eq__(self, o: object) -&gt; bool:
        if not isinstance(o, GithubProject):
            return False

        return (
            self.repo == o.repo
            and self.namespace == o.namespace
            and self.service == o.service
            and self.read_only == o.read_only
        )

    @property
    def description(self) -&gt; str:
        return self.github_repo.description

    @description.setter
    def description(self, new_description: str) -&gt; None:
        self.github_repo.edit(description=new_description)

    @property
    def has_issues(self) -&gt; bool:
        return self.github_repo.has_issues

    def _construct_fork_project(self) -&gt; Optional[&#34;GithubProject&#34;]:
        gh_user = self.github_instance.get_user()
        user_login = gh_user.login
        try:
            project = GithubProject(
                self.repo, self.service, namespace=user_login, read_only=self.read_only
            )
            if not project.github_repo:
                # The github_repo attribute is lazy.
                return None
            return project
        except github.GithubException as ex:
            logger.debug(f&#34;Project {user_login}/{self.repo} does not exist: {ex}&#34;)
            return None

    def exists(self) -&gt; bool:
        try:
            _ = self.github_repo
            return True
        except UnknownObjectException as ex:
            if &#34;Not Found&#34; in str(ex):
                return False
            raise GithubAPIException from ex

    def is_private(self) -&gt; bool:
        return self.github_repo.private

    def is_forked(self) -&gt; bool:
        return bool(self._construct_fork_project())

    @property
    def is_fork(self) -&gt; bool:
        return self.github_repo.fork

    @property
    def parent(self) -&gt; Optional[&#34;GithubProject&#34;]:
        return (
            self.service.get_project_from_github_repository(self.github_repo.parent)
            if self.is_fork
            else None
        )

    @property
    def default_branch(self):
        return self.github_repo.default_branch

    def get_branches(self) -&gt; List[str]:
        return [branch.name for branch in self.github_repo.get_branches()]

    def get_description(self) -&gt; str:
        return self.github_repo.description

    def add_user(self, user: str, access_level: AccessLevel) -&gt; None:
        access_dict = {
            AccessLevel.pull: &#34;Pull&#34;,
            AccessLevel.triage: &#34;Triage&#34;,
            AccessLevel.push: &#34;Push&#34;,
            AccessLevel.admin: &#34;Admin&#34;,
            AccessLevel.maintain: &#34;Maintain&#34;,
        }
        try:
            invitation = self.github_repo.add_to_collaborators(
                user, permission=access_dict[access_level]
            )
        except Exception as ex:
            raise GithubAPIException(f&#34;User {user} not found&#34;) from ex

        if invitation is None:
            raise GithubAPIException(&#34;User already added&#34;)

    def request_access(self):
        raise OperationNotSupported(&#34;Not possible on GitHub&#34;)

    def get_fork(self, create: bool = True) -&gt; Optional[&#34;GithubProject&#34;]:
        username = self.service.user.get_username()
        for fork in self.get_forks():
            if fork.github_repo.owner.login == username:
                return fork

        if not self.is_forked():
            if create:
                return self.fork_create()
            else:
                logger.info(
                    f&#34;Fork of {self.github_repo.full_name}&#34;
                    &#34; does not exist and we were asked not to create it.&#34;
                )
                return None
        return self._construct_fork_project()

    def get_owners(self) -&gt; List[str]:
        # in case of github, repository has only one owner
        return [self.github_repo.owner.login]

    def __get_collaborators(self) -&gt; Set[str]:
        try:
            collaborators = self._get_collaborators_with_permission()
        except github.GithubException:
            logger.debug(
                &#34;Current Github token must have push access to view repository permissions.&#34;
            )
            return set()

        usernames = []
        for login, permission in collaborators.items():
            if permission in self.CAN_MERGE_PERMS:
                usernames.append(login)

        return set(usernames)

    def who_can_close_issue(self) -&gt; Set[str]:
        return self.__get_collaborators()

    def who_can_merge_pr(self) -&gt; Set[str]:
        return self.__get_collaborators()

    def can_merge_pr(self, username) -&gt; bool:
        return (
            self.github_repo.get_collaborator_permission(username)
            in self.CAN_MERGE_PERMS
        )

    def _get_collaborators_with_permission(self) -&gt; dict:
        &#34;&#34;&#34;
        Get all project collaborators in dictionary with permission association.

        Returns:
            Dictionary with logins of collaborators and their permission level.
        &#34;&#34;&#34;
        collaborators = {}
        users = self.github_repo.get_collaborators()
        for user in users:
            permission = self.github_repo.get_collaborator_permission(user)
            collaborators[user.login] = permission
        return collaborators

    @indirect(GithubIssue.get_list)
    def get_issue_list(
        self,
        status: IssueStatus = IssueStatus.open,
        author: Optional[str] = None,
        assignee: Optional[str] = None,
        labels: Optional[List[str]] = None,
    ) -&gt; List[Issue]:
        pass

    @indirect(GithubIssue.get)
    def get_issue(self, issue_id: int) -&gt; Issue:
        pass

    @indirect(GithubIssue.create)
    def create_issue(
        self,
        title: str,
        body: str,
        private: Optional[bool] = None,
        labels: Optional[List[str]] = None,
        assignees: Optional[List[str]] = None,
    ) -&gt; Issue:
        pass

    def delete(self) -&gt; None:
        self.github_repo.delete()

    @indirect(GithubPullRequest.get_list)
    def get_pr_list(self, status: PRStatus = PRStatus.open) -&gt; List[PullRequest]:
        pass

    @indirect(GithubPullRequest.get)
    def get_pr(self, pr_id: int) -&gt; PullRequest:
        pass

    def get_sha_from_tag(self, tag_name: str) -&gt; str:
        # TODO: This is ugly. Can we do it better?
        all_tags = self.github_repo.get_tags()
        for tag in all_tags:
            if tag.name == tag_name:
                return tag.commit.sha
        raise GithubAPIException(f&#34;Tag {tag_name} was not found.&#34;)

    def get_tag_from_tag_name(self, tag_name: str) -&gt; Optional[GitTag]:
        &#34;&#34;&#34;
        Get a tag based on a tag name.

        Args:
            tag_name: Name of the tag.

        Returns:
            GitTag associated with the given tag name or `None`.
        &#34;&#34;&#34;
        all_tags = self.github_repo.get_tags()
        for tag in all_tags:
            if tag.name == tag_name:
                return GitTag(name=tag.name, commit_sha=tag.commit.sha)
        return None

    @if_readonly(return_function=GitProjectReadOnly.create_pr)
    @indirect(GithubPullRequest.create)
    def create_pr(
        self,
        title: str,
        body: str,
        target_branch: str,
        source_branch: str,
        fork_username: str = None,
    ) -&gt; PullRequest:
        pass

    @if_readonly(
        return_function=GitProjectReadOnly.commit_comment,
        log_message=&#34;Create Comment to commit&#34;,
    )
    def commit_comment(
        self, commit: str, body: str, filename: str = None, row: int = None
    ) -&gt; CommitComment:
        github_commit: Commit = self.github_repo.get_commit(commit)
        if filename and row:
            comment = github_commit.create_comment(
                body=body, position=row, path=filename
            )
        else:
            comment = github_commit.create_comment(body=body)
        return self._commit_comment_from_github_object(comment)

    @staticmethod
    def _commit_comment_from_github_object(
        raw_commit_coment: GithubCommitComment,
    ) -&gt; CommitComment:
        return CommitComment(
            body=raw_commit_coment.body,
            author=raw_commit_coment.user.login,
            sha=raw_commit_coment.commit_id,
        )

    def get_commit_comments(self, commit: str) -&gt; List[CommitComment]:
        github_commit: Commit = self.github_repo.get_commit(commit)
        return [
            self._commit_comment_from_github_object(comment)
            for comment in github_commit.get_comments()
        ]

    @if_readonly(
        return_function=GitProjectReadOnly.set_commit_status,
        log_message=&#34;Create a status on a commit&#34;,
    )
    @indirect(GithubCommitFlag.set)
    def set_commit_status(
        self,
        commit: str,
        state: Union[CommitStatus, str],
        target_url: str,
        description: str,
        context: str,
        trim: bool = False,
    ):
        pass

    @indirect(GithubCommitFlag.get)
    def get_commit_statuses(self, commit: str) -&gt; List[CommitFlag]:
        pass

    @indirect(GithubCheckRun.get)
    def get_check_run(
        self,
        check_run_id: Optional[int] = None,
        commit_sha: Optional[str] = None,
    ) -&gt; Optional[&#34;GithubCheckRun&#34;]:
        pass

    @indirect(GithubCheckRun.create)
    def create_check_run(
        self,
        name: str,
        commit_sha: str,
        url: Optional[str] = None,
        external_id: Optional[str] = None,
        status: GithubCheckRunStatus = GithubCheckRunStatus.queued,
        started_at: Optional[datetime.datetime] = None,
        conclusion: Optional[GithubCheckRunResult] = None,
        completed_at: Optional[datetime.datetime] = None,
        output: Optional[GithubCheckRunOutput] = None,
        actions: Optional[List[Dict[str, str]]] = None,
    ) -&gt; &#34;GithubCheckRun&#34;:
        pass

    @indirect(GithubCheckRun.get_list)
    def get_check_runs(
        self,
        commit_sha: str,
        name: Optional[str] = None,
        status: Optional[GithubCheckRunStatus] = None,
    ) -&gt; List[&#34;GithubCheckRun&#34;]:
        pass

    def get_git_urls(self) -&gt; Dict[str, str]:
        return {&#34;git&#34;: self.github_repo.clone_url, &#34;ssh&#34;: self.github_repo.ssh_url}

    @if_readonly(return_function=GitProjectReadOnly.fork_create)
    def fork_create(self, namespace: Optional[str] = None) -&gt; &#34;GithubProject&#34;:
        fork_repo = (
            self.github_repo.create_fork(organization=namespace)
            if namespace
            else self.github_repo.create_fork()
        )

        fork = self.service.get_project_from_github_repository(fork_repo)
        logger.debug(f&#34;Forked to {fork.namespace}/{fork.repo}&#34;)
        return fork

    def change_token(self, new_token: str):
        raise OperationNotSupported

    def get_file_content(self, path: str, ref=None) -&gt; str:
        ref = ref or self.default_branch
        try:
            return self.github_repo.get_contents(
                path=path, ref=ref
            ).decoded_content.decode()
        except (UnknownObjectException, GithubException) as ex:
            if ex.status == 404:
                raise FileNotFoundError(f&#34;File &#39;{path}&#39; on {ref} not found&#34;) from ex
            raise GithubAPIException() from ex

    def get_files(
        self, ref: str = None, filter_regex: str = None, recursive: bool = False
    ) -&gt; List[str]:
        ref = ref or self.default_branch
        paths = []
        contents = self.github_repo.get_contents(path=&#34;&#34;, ref=ref)

        if recursive:
            while contents:
                file_content = contents.pop(0)
                if file_content.type == &#34;dir&#34;:
                    contents.extend(
                        self.github_repo.get_contents(path=file_content.path, ref=ref)
                    )
                else:
                    paths.append(file_content.path)

        else:
            paths = [
                file_content.path
                for file_content in contents
                if file_content.type != &#34;dir&#34;
            ]

        if filter_regex:
            paths = filter_paths(paths, filter_regex)

        return paths

    def get_labels(self):
        &#34;&#34;&#34;
        Get list of labels in the repository.

        Returns:
            List of labels in the repository.
        &#34;&#34;&#34;
        return list(self.github_repo.get_labels())

    def update_labels(self, labels):
        &#34;&#34;&#34;
        Update the labels of the repository. (No deletion, only add not existing ones.)

        Args:
            labels: List of labels to be added.

        Returns:
            Number of added labels.
        &#34;&#34;&#34;
        current_label_names = [la.name for la in list(self.github_repo.get_labels())]
        changes = 0
        for label in labels:
            if label.name not in current_label_names:
                color = self._normalize_label_color(color=label.color)
                self.github_repo.create_label(
                    name=label.name, color=color, description=label.description or &#34;&#34;
                )

                changes += 1
        return changes

    @staticmethod
    def _normalize_label_color(color):
        if color.startswith(&#34;#&#34;):
            return color[1:]
        return color

    @indirect(GithubRelease.get)
    def get_release(self, identifier=None, name=None, tag_name=None) -&gt; GithubRelease:
        pass

    @indirect(GithubRelease.get_latest)
    def get_latest_release(self) -&gt; Optional[GithubRelease]:
        pass

    @indirect(GithubRelease.get_list)
    def get_releases(self) -&gt; List[Release]:
        pass

    @indirect(GithubRelease.create)
    def create_release(self, tag: str, name: str, message: str) -&gt; GithubRelease:
        pass

    def get_forks(self) -&gt; List[&#34;GithubProject&#34;]:
        return [
            self.service.get_project_from_github_repository(fork)
            for fork in self.github_repo.get_forks()
            if fork.owner
        ]

    def get_web_url(self) -&gt; str:
        return self.github_repo.html_url

    def get_tags(self) -&gt; List[&#34;GitTag&#34;]:
        return [GitTag(tag.name, tag.commit.sha) for tag in self.github_repo.get_tags()]

    def get_sha_from_branch(self, branch: str) -&gt; Optional[str]:
        try:
            return self.github_repo.get_branch(branch).commit.sha
        except GithubException as ex:
            if ex.status == 404:
                return None
            raise GithubAPIException from ex

    def get_contributors(self) -&gt; Set[str]:
        &#34;&#34;&#34;
        Returns:
            Logins of contributors to the project.
        &#34;&#34;&#34;
        return set(map(lambda c: c.login, self.github_repo.get_contributors()))

    def users_with_write_access(self) -&gt; Set[str]:
        return self.__get_collaborators()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ogr.services.base.BaseGitProject" href="../base.html#ogr.services.base.BaseGitProject">BaseGitProject</a></li>
<li><a title="ogr.abstract.GitProject" href="../../abstract.html#ogr.abstract.GitProject">GitProject</a></li>
<li><a title="ogr.abstract.OgrAbstractClass" href="../../abstract.html#ogr.abstract.OgrAbstractClass">OgrAbstractClass</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="ogr.services.github.project.GithubProject.CAN_MERGE_PERMS"><code class="name">var <span class="ident">CAN_MERGE_PERMS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ogr.services.github.project.GithubProject.service"><code class="name">var <span class="ident">service</span> : <a title="ogr.services.github.service.GithubService" href="service.html#ogr.services.github.service.GithubService">GithubService</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="ogr.services.github.project.GithubProject.github_instance"><code class="name">var <span class="ident">github_instance</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def github_instance(self):
    if not self._github_instance:
        self._github_instance = self.service.get_pygithub_instance(
            self.namespace, self.repo
        )

    return self._github_instance</code></pre>
</details>
</dd>
<dt id="ogr.services.github.project.GithubProject.github_repo"><code class="name">var <span class="ident">github_repo</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def github_repo(self):
    if not self._github_repo:
        self._github_repo = self.github_instance.get_repo(
            full_name_or_id=f&#34;{self.namespace}/{self.repo}&#34;
        )
    return self._github_repo</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ogr.services.github.project.GithubProject.create_check_run"><code class="name flex">
<span>def <span class="ident">create_check_run</span></span>(<span>self, name: str, commit_sha: str, url: Optional[str] = None, external_id: Optional[str] = None, status: <a title="ogr.services.github.check_run.GithubCheckRunStatus" href="check_run.html#ogr.services.github.check_run.GithubCheckRunStatus">GithubCheckRunStatus</a> = GithubCheckRunStatus.queued, started_at: Optional[datetime.datetime] = None, conclusion: Optional[<a title="ogr.services.github.check_run.GithubCheckRunResult" href="check_run.html#ogr.services.github.check_run.GithubCheckRunResult">GithubCheckRunResult</a>] = None, completed_at: Optional[datetime.datetime] = None, output: Optional[Dict[str, Union[str, List[Dict[str, Union[str, int]]]]]] = None, actions: Optional[List[Dict[str, str]]] = None) ‑> <a title="ogr.services.github.check_run.GithubCheckRun" href="check_run.html#ogr.services.github.check_run.GithubCheckRun">GithubCheckRun</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@indirect(GithubCheckRun.create)
def create_check_run(
    self,
    name: str,
    commit_sha: str,
    url: Optional[str] = None,
    external_id: Optional[str] = None,
    status: GithubCheckRunStatus = GithubCheckRunStatus.queued,
    started_at: Optional[datetime.datetime] = None,
    conclusion: Optional[GithubCheckRunResult] = None,
    completed_at: Optional[datetime.datetime] = None,
    output: Optional[GithubCheckRunOutput] = None,
    actions: Optional[List[Dict[str, str]]] = None,
) -&gt; &#34;GithubCheckRun&#34;:
    pass</code></pre>
</details>
</dd>
<dt id="ogr.services.github.project.GithubProject.get_check_run"><code class="name flex">
<span>def <span class="ident">get_check_run</span></span>(<span>self, check_run_id: Optional[int] = None, commit_sha: Optional[str] = None) ‑> Optional[<a title="ogr.services.github.check_run.GithubCheckRun" href="check_run.html#ogr.services.github.check_run.GithubCheckRun">GithubCheckRun</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@indirect(GithubCheckRun.get)
def get_check_run(
    self,
    check_run_id: Optional[int] = None,
    commit_sha: Optional[str] = None,
) -&gt; Optional[&#34;GithubCheckRun&#34;]:
    pass</code></pre>
</details>
</dd>
<dt id="ogr.services.github.project.GithubProject.get_check_runs"><code class="name flex">
<span>def <span class="ident">get_check_runs</span></span>(<span>self, commit_sha: str, name: Optional[str] = None, status: Optional[<a title="ogr.services.github.check_run.GithubCheckRunStatus" href="check_run.html#ogr.services.github.check_run.GithubCheckRunStatus">GithubCheckRunStatus</a>] = None) ‑> List[<a title="ogr.services.github.check_run.GithubCheckRun" href="check_run.html#ogr.services.github.check_run.GithubCheckRun">GithubCheckRun</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@indirect(GithubCheckRun.get_list)
def get_check_runs(
    self,
    commit_sha: str,
    name: Optional[str] = None,
    status: Optional[GithubCheckRunStatus] = None,
) -&gt; List[&#34;GithubCheckRun&#34;]:
    pass</code></pre>
</details>
</dd>
<dt id="ogr.services.github.project.GithubProject.get_contributors"><code class="name flex">
<span>def <span class="ident">get_contributors</span></span>(<span>self) ‑> Set[str]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Logins of contributors to the project.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_contributors(self) -&gt; Set[str]:
    &#34;&#34;&#34;
    Returns:
        Logins of contributors to the project.
    &#34;&#34;&#34;
    return set(map(lambda c: c.login, self.github_repo.get_contributors()))</code></pre>
</details>
</dd>
<dt id="ogr.services.github.project.GithubProject.get_labels"><code class="name flex">
<span>def <span class="ident">get_labels</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get list of labels in the repository.</p>
<h2 id="returns">Returns</h2>
<p>List of labels in the repository.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_labels(self):
    &#34;&#34;&#34;
    Get list of labels in the repository.

    Returns:
        List of labels in the repository.
    &#34;&#34;&#34;
    return list(self.github_repo.get_labels())</code></pre>
</details>
</dd>
<dt id="ogr.services.github.project.GithubProject.get_tag_from_tag_name"><code class="name flex">
<span>def <span class="ident">get_tag_from_tag_name</span></span>(<span>self, tag_name: str) ‑> Optional[<a title="ogr.abstract.GitTag" href="../../abstract.html#ogr.abstract.GitTag">GitTag</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get a tag based on a tag name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tag_name</code></strong></dt>
<dd>Name of the tag.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>GitTag associated with the given tag name or <code>None</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tag_from_tag_name(self, tag_name: str) -&gt; Optional[GitTag]:
    &#34;&#34;&#34;
    Get a tag based on a tag name.

    Args:
        tag_name: Name of the tag.

    Returns:
        GitTag associated with the given tag name or `None`.
    &#34;&#34;&#34;
    all_tags = self.github_repo.get_tags()
    for tag in all_tags:
        if tag.name == tag_name:
            return GitTag(name=tag.name, commit_sha=tag.commit.sha)
    return None</code></pre>
</details>
</dd>
<dt id="ogr.services.github.project.GithubProject.update_labels"><code class="name flex">
<span>def <span class="ident">update_labels</span></span>(<span>self, labels)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the labels of the repository. (No deletion, only add not existing ones.)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>labels</code></strong></dt>
<dd>List of labels to be added.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Number of added labels.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_labels(self, labels):
    &#34;&#34;&#34;
    Update the labels of the repository. (No deletion, only add not existing ones.)

    Args:
        labels: List of labels to be added.

    Returns:
        Number of added labels.
    &#34;&#34;&#34;
    current_label_names = [la.name for la in list(self.github_repo.get_labels())]
    changes = 0
    for label in labels:
        if label.name not in current_label_names:
            color = self._normalize_label_color(color=label.color)
            self.github_repo.create_label(
                name=label.name, color=color, description=label.description or &#34;&#34;
            )

            changes += 1
    return changes</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ogr.services.base.BaseGitProject" href="../base.html#ogr.services.base.BaseGitProject">BaseGitProject</a></b></code>:
<ul class="hlist">
<li><code><a title="ogr.services.base.BaseGitProject.add_group" href="../../abstract.html#ogr.abstract.GitProject.add_group">add_group</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.add_user" href="../../abstract.html#ogr.abstract.GitProject.add_user">add_user</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.can_merge_pr" href="../../abstract.html#ogr.abstract.GitProject.can_merge_pr">can_merge_pr</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.change_token" href="../../abstract.html#ogr.abstract.GitProject.change_token">change_token</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.commit_comment" href="../../abstract.html#ogr.abstract.GitProject.commit_comment">commit_comment</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.create_issue" href="../../abstract.html#ogr.abstract.GitProject.create_issue">create_issue</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.create_pr" href="../../abstract.html#ogr.abstract.GitProject.create_pr">create_pr</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.create_release" href="../../abstract.html#ogr.abstract.GitProject.create_release">create_release</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.default_branch" href="../../abstract.html#ogr.abstract.GitProject.default_branch">default_branch</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.delete" href="../../abstract.html#ogr.abstract.GitProject.delete">delete</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.description" href="../../abstract.html#ogr.abstract.GitProject.description">description</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.exists" href="../../abstract.html#ogr.abstract.GitProject.exists">exists</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.fork_create" href="../../abstract.html#ogr.abstract.GitProject.fork_create">fork_create</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.full_repo_name" href="../../abstract.html#ogr.abstract.GitProject.full_repo_name">full_repo_name</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_branches" href="../../abstract.html#ogr.abstract.GitProject.get_branches">get_branches</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_commit_comments" href="../../abstract.html#ogr.abstract.GitProject.get_commit_comments">get_commit_comments</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_commit_statuses" href="../../abstract.html#ogr.abstract.GitProject.get_commit_statuses">get_commit_statuses</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_description" href="../../abstract.html#ogr.abstract.GitProject.get_description">get_description</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_file_content" href="../../abstract.html#ogr.abstract.GitProject.get_file_content">get_file_content</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_files" href="../../abstract.html#ogr.abstract.GitProject.get_files">get_files</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_fork" href="../../abstract.html#ogr.abstract.GitProject.get_fork">get_fork</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_forks" href="../../abstract.html#ogr.abstract.GitProject.get_forks">get_forks</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_git_urls" href="../../abstract.html#ogr.abstract.GitProject.get_git_urls">get_git_urls</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_issue" href="../../abstract.html#ogr.abstract.GitProject.get_issue">get_issue</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_issue_info" href="../../abstract.html#ogr.abstract.GitProject.get_issue_info">get_issue_info</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_issue_list" href="../../abstract.html#ogr.abstract.GitProject.get_issue_list">get_issue_list</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_latest_release" href="../../abstract.html#ogr.abstract.GitProject.get_latest_release">get_latest_release</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_owners" href="../../abstract.html#ogr.abstract.GitProject.get_owners">get_owners</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_pr" href="../../abstract.html#ogr.abstract.GitProject.get_pr">get_pr</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_pr_list" href="../../abstract.html#ogr.abstract.GitProject.get_pr_list">get_pr_list</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_release" href="../../abstract.html#ogr.abstract.GitProject.get_release">get_release</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_releases" href="../../abstract.html#ogr.abstract.GitProject.get_releases">get_releases</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_sha_from_branch" href="../../abstract.html#ogr.abstract.GitProject.get_sha_from_branch">get_sha_from_branch</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_sha_from_tag" href="../../abstract.html#ogr.abstract.GitProject.get_sha_from_tag">get_sha_from_tag</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_tags" href="../../abstract.html#ogr.abstract.GitProject.get_tags">get_tags</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_web_url" href="../../abstract.html#ogr.abstract.GitProject.get_web_url">get_web_url</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.has_issues" href="../../abstract.html#ogr.abstract.GitProject.has_issues">has_issues</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.has_write_access" href="../../abstract.html#ogr.abstract.GitProject.has_write_access">has_write_access</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.is_fork" href="../../abstract.html#ogr.abstract.GitProject.is_fork">is_fork</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.is_forked" href="../../abstract.html#ogr.abstract.GitProject.is_forked">is_forked</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.is_private" href="../../abstract.html#ogr.abstract.GitProject.is_private">is_private</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.parent" href="../../abstract.html#ogr.abstract.GitProject.parent">parent</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.request_access" href="../../abstract.html#ogr.abstract.GitProject.request_access">request_access</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.set_commit_status" href="../../abstract.html#ogr.abstract.GitProject.set_commit_status">set_commit_status</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.users_with_write_access" href="../../abstract.html#ogr.abstract.GitProject.users_with_write_access">users_with_write_access</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.who_can_close_issue" href="../../abstract.html#ogr.abstract.GitProject.who_can_close_issue">who_can_close_issue</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.who_can_merge_pr" href="../../abstract.html#ogr.abstract.GitProject.who_can_merge_pr">who_can_merge_pr</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ogr.services.github" href="index.html">ogr.services.github</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ogr.services.github.project.GithubProject" href="#ogr.services.github.project.GithubProject">GithubProject</a></code></h4>
<ul class="">
<li><code><a title="ogr.services.github.project.GithubProject.CAN_MERGE_PERMS" href="#ogr.services.github.project.GithubProject.CAN_MERGE_PERMS">CAN_MERGE_PERMS</a></code></li>
<li><code><a title="ogr.services.github.project.GithubProject.create_check_run" href="#ogr.services.github.project.GithubProject.create_check_run">create_check_run</a></code></li>
<li><code><a title="ogr.services.github.project.GithubProject.get_check_run" href="#ogr.services.github.project.GithubProject.get_check_run">get_check_run</a></code></li>
<li><code><a title="ogr.services.github.project.GithubProject.get_check_runs" href="#ogr.services.github.project.GithubProject.get_check_runs">get_check_runs</a></code></li>
<li><code><a title="ogr.services.github.project.GithubProject.get_contributors" href="#ogr.services.github.project.GithubProject.get_contributors">get_contributors</a></code></li>
<li><code><a title="ogr.services.github.project.GithubProject.get_labels" href="#ogr.services.github.project.GithubProject.get_labels">get_labels</a></code></li>
<li><code><a title="ogr.services.github.project.GithubProject.get_tag_from_tag_name" href="#ogr.services.github.project.GithubProject.get_tag_from_tag_name">get_tag_from_tag_name</a></code></li>
<li><code><a title="ogr.services.github.project.GithubProject.github_instance" href="#ogr.services.github.project.GithubProject.github_instance">github_instance</a></code></li>
<li><code><a title="ogr.services.github.project.GithubProject.github_repo" href="#ogr.services.github.project.GithubProject.github_repo">github_repo</a></code></li>
<li><code><a title="ogr.services.github.project.GithubProject.service" href="#ogr.services.github.project.GithubProject.service">service</a></code></li>
<li><code><a title="ogr.services.github.project.GithubProject.update_labels" href="#ogr.services.github.project.GithubProject.update_labels">update_labels</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>